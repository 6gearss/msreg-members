import csv
import os
import sys
import logging
from datetime import datetime
from dotenv import load_dotenv
from msreg_client import MotorsportRegClient

# Setup logging
if not os.path.exists('logs'):
    os.makedirs('logs')
log_filename = f"logs/member_update_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(log_filename),
        logging.StreamHandler(sys.stdout)
    ]
)



def get_all_members(client):
    logging.info("Fetching member list from MotorsportReg...")
    members_data = client.get_members()
    
    if not members_data:
        logging.error("Failed to retrieve data from API.")
        return {}

    response_data = members_data.get('response', {})
    
    raw_members = []
    if 'members' in response_data:
        raw_members = response_data['members']
    elif 'payload' in response_data:
        payload = response_data['payload']
        if 'members' in payload:
            raw_members = payload['members']
        elif 'member' in payload:
            m = payload['member']
            if isinstance(m, dict):
                raw_members = [m]
    
    # Create a dictionary keyed by uniqueId (as string) for fast lookup
    members_map = {}
    for m in raw_members:
        uid = str(m.get('uniqueId', '')).strip()
        if uid:
            members_map[uid] = m
            
    logging.info(f"Loaded {len(members_map)} members indexed by uniqueId.")
    return members_map

def process_csv(filename, client, members_map):
    logging.info(f"Processing CSV file: {filename}")
    
    if not os.path.exists(filename):
        logging.error(f"CSV file not found: {filename}")
        return

    with open(filename, 'r', encoding='utf-8') as f:
        # Assuming headerless or specific header checks
        # Based on user prompt: firstName lastName memberId uniqueId memberEnd
        # We can try to use csv.DictReader if there is a header, or csv.reader if not.
        # Let's peek at the first line to guess.
        
        # Actually, user request implies a specific format. 
        # "firstName lastName memberId uniqueId memberEnd" - sounds like it might be the output of main.py
        # main.py output: print(f"{f_name},{l_name},{member_id},{unique_id},{member_end}")
        # So it's comma separated.
        
        reader = csv.reader(f)
        row_count = 0
        update_count = 0
        error_count = 0
        
        for row in reader:
            row_count += 1
            if not row or len(row) < 4:
                # Minimum fields needed: ... uniqueId (4th col), memberId (3rd col)
                # If generated by main.py, len is 5.
                logging.warning(f"Row {row_count}: Skipped invalid row: {row}")
                continue
            
            # Extract fields based on expected order
            # 0: firstName, 1: lastName, 2: memberId (csv), 3: uniqueId (csv), 4: memberEnd
            try:
                f_name = row[0].strip()
                l_name = row[1].strip()
                csv_member_id = row[2].strip()
                csv_unique_id = row[3].strip()
                
                # Check 1: Find user by uniqueId
                if csv_unique_id not in members_map:
                    logging.warning(f"Row {row_count}: User not found API with uniqueId '{csv_unique_id}' ({f_name} {l_name}).")
                    error_count += 1
                    continue
                
                member = members_map[csv_unique_id]
                api_member_id = str(member.get('memberId', '')).strip()
                member_guid = member.get('id')
                
                if not member_guid:
                    logging.error(f"Row {row_count}: Member {csv_unique_id} found but has no GUID (id). Cannot update.")
                    error_count += 1
                    continue

                # Check 2: Verify memberId
                # "if the memberId is empty or doesn't match the value in the CSV"
                # This implies the CSV acts as the source of truth for memberId? 
                # OR is the CSV checking against the API? 
                # "if the memberId is empty or doesn't match the value in the CSV, update the memberId."
                # This usually means update the API with the value FROM the CSV.
                
                if not csv_member_id:
                     # If CSV memberId is empty, do we clear it on API? Or just skip?
                     # Prompt says "if the memberId is empty [on API?] or doesn't match... update".
                     # If CSV has a value, we likely want to push it. 
                     # If CSV is empty, maybe we don't do anything? 
                     # Assuming: Update API to match CSV memberId if they differ.
                     logging.info(f"Row {row_count}: CSV memberId is empty for {f_name} {l_name}. Skipping update.")
                     continue
                
                if api_member_id != csv_member_id:
                    logging.info(f"Row {row_count}: Mismatch for ({f_name} {l_name} [{csv_unique_id}]). API: '{api_member_id}' -> CSV: '{csv_member_id}'. Updating...")
                    
                    update_payload = {"memberId": csv_member_id}
                    response = client.update_member(member_guid, update_payload)
                    
                    if response:
                        logging.info(f"Row {row_count}: Update successful.")
                        # Update local map to reflect change prevents multi-updates if duplicate rows
                        member['memberId'] = csv_member_id
                        update_count += 1
                    else:
                        logging.error(f"Row {row_count}: Update FAILED via API.")
                        error_count += 1
                else:
                    logging.info(f"Row {row_count}: MemberId matches ({api_member_id}). No action needed.")
                    
            except Exception as e:
                logging.error(f"Row {row_count}: Error processing row: {e}")
                error_count += 1

        logging.info("="*30)
        logging.info(f"Processing complete.")
        logging.info(f"Total rows: {row_count}")
        logging.info(f"Updates performed: {update_count}")
        logging.info(f"Errors/Skips: {error_count}")
        logging.info(f"Log saved to: {log_filename}")

def main():
    # Load environment variables
    load_dotenv()
    
    # Organization ID from environment
    ORG_ID = os.environ.get("MSR_ORG_ID")

    username = os.environ.get("MSR_USERNAME")
    password = os.environ.get("MSR_PASSWORD")

    if not username:
        username = input("Enter your MotorsportReg Email/Username: ")
    
    if not password:
        import getpass
        password = getpass.getpass("Enter your MotorsportReg Password: ")

    if not username or not password:
        print("Error: Username and password are required.")
        sys.exit(1)
        
    csv_file = input("Enter the path to the CSV file to process (default: members.csv): ").strip()
    if not csv_file:
        csv_file = "members.csv"
        print(f"Using default file: {csv_file}")

    client = MotorsportRegClient(username, password, ORG_ID)
    
    members_map = get_all_members(client)
    
    if members_map:
        process_csv(csv_file, client, members_map)

if __name__ == "__main__":
    main()
